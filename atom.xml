<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>C#</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cjsmy1973.github.io/"/>
  <updated>2019-08-12T15:13:12.631Z</updated>
  <id>https://cjsmy1973.github.io/</id>
  
  <author>
    <name>Tom Cheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>同步上下文</title>
    <link href="https://cjsmy1973.github.io/2019/08/12/%E5%90%8C%E6%AD%A5%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://cjsmy1973.github.io/2019/08/12/同步上下文/</id>
    <published>2019-08-12T14:29:37.000Z</published>
    <updated>2019-08-12T15:13:12.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这是大标题"><a href="#这是大标题" class="headerlink" title="这是大标题"></a>这是大标题</h1><h2 id="这是中标题"><a href="#这是中标题" class="headerlink" title="这是中标题"></a>这是中标题</h2><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p>##二级标题  </p><p>###三级标题  </p><p>####四级标题  </p><p>#####五级标题  </p><p>######六级标题  </p><pre><code>单行文本多行文本多行文本</code></pre><p><code>文字高亮</code></p><p><a href="https://cjsmy1973.github.io/">超链接</a></p><p>*圆点符</p><blockquote><p>缩进</p></blockquote><p>view plaincopy在CODE上查看代码片派生到我的代码片</p><p><img src="http://www.baidu.com/img/bdlogo.gif" alt></p><p><img src="http://www.baidu.com/img/bdlogo.gif" alt="baidu" title="百度logo">  </p><p><img src="https://github.com/guodongxiaren/ImageCache/raw/master/Logo/foryou.gif" alt>  </p><h1 id="同步上下文"><a href="#同步上下文" class="headerlink" title="同步上下文"></a>同步上下文</h1><p>个人理解同步上下文的出现是一个线程为了操作另一个线程里的变量而产生的，做过WF，WPF应该都知道其UI线程实现了同步上下文机制，使得另一个线程可以访问并修改UI线程里的元素。在演示前我们先了解下关于线程的一些知识</p><h2 id="前台线程和后台线程"><a href="#前台线程和后台线程" class="headerlink" title="前台线程和后台线程"></a>前台线程和后台线程</h2><p>我们都知道线程类有个IsBackground属性，那么什么是后台线程呢，后台线程就是emmmmm<br>。。。大家都知道控制台应用程序有个main方法作为程序的入口，如果你在运行了一个开启后台线程的方法，若在main函数执行完毕后或者应用程序关闭前后台线程还没有执行完毕，后台线程会被强制关闭，所以我们一般会加个Console.ReadLine()防止线程被关闭。  </p><p>而前台线程会阻止主线程运行结束，一般来说，Thread类产生的线程为前台线程，而Task类产生的线程为后台线程</p><h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><p>在<code>.net 4.0</code>之前，我们只能通过Thread类进行线程中的操作，我们可以直接通过其构造函数实例化，通过start方法执行进程，同时也可以设置其是否为后台线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread thread=new Thread(Method);</span><br><span class="line">thread.IsBackground = false;//设置是否为后台线程</span><br><span class="line">thread.Start();</span><br><span class="line">void Method()</span><br><span class="line">&#123;</span><br><span class="line">   //do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Task类"><a href="#Task类" class="headerlink" title="Task类"></a>Task类</h2><p><code>.net 4.0</code>后出现了更为精简的任务类，其和Thread类的不同在于，task运行于线程池，其线程数量是动态创建的，于schedule类管理，任务可以在不同线程中运行。Task类有4种方式启动<br>我们这里只演示task.factory类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Task.Factory.StartNew(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">   //do something</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="异步方法对同步上下文的表现"><a href="#异步方法对同步上下文的表现" class="headerlink" title="异步方法对同步上下文的表现"></a>异步方法对同步上下文的表现</h2><p>在异步方法中，大家都知道await关键字，在控制台应用程序中如果一个方法在await操作后还有其他操作，这些其他操作是由完成await对于任务的线程执行的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public async void doSomething()&#123;</span><br><span class="line">var curentId=hread.CurrentThread.ManagedThreadId;</span><br><span class="line">awaitTask.Factory.StartNew(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    //do something</span><br><span class="line">&#125;)</span><br><span class="line">    //do something</span><br><span class="line">curentId=hread.CurrentThread.ManagedThreadId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试运行后发现curentId的值发生了改变</p><p>但是如果应用程序拥有同步上下文，await执行后的语句会自动切换到上下文对应的线程去执行，例如对于winform程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">      public TestFormThread()</span><br><span class="line">      &#123;</span><br><span class="line">          InitializeComponent();</span><br><span class="line">          TestThread();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">public async void TestThread()</span><br><span class="line">      &#123;</span><br><span class="line">          (string flag,string threadId)= await Task.Factory.StartNew(() =&gt;</span><br><span class="line">          &#123;</span><br><span class="line">              Thread.Sleep(3000);</span><br><span class="line">              var isBackground = Thread.CurrentThread.IsBackground.ToString();</span><br><span class="line">              var id = Thread.CurrentThread.ManagedThreadId.ToString(); </span><br><span class="line">              return (isBackground, id);</span><br><span class="line">          &#125;);</span><br><span class="line">          label1.Text = threadId;</span><br><span class="line">          Application.DoEvents();</span><br><span class="line">          Thread.Sleep(1000);</span><br><span class="line">          label1.Text  = Thread.CurrentThread.ManagedThreadId.ToString();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>其执行结果是</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;这是大标题&quot;&gt;&lt;a href=&quot;#这是大标题&quot; class=&quot;headerlink&quot; title=&quot;这是大标题&quot;&gt;&lt;/a&gt;这是大标题&lt;/h1&gt;&lt;h2 id=&quot;这是中标题&quot;&gt;&lt;a href=&quot;#这是中标题&quot; class=&quot;headerlink&quot; title=&quot;这是中
      
    
    </summary>
    
      <category term="多线程" scheme="https://cjsmy1973.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="随记" scheme="https://cjsmy1973.github.io/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Json文件</title>
    <link href="https://cjsmy1973.github.io/2019/08/11/Json%E6%96%87%E4%BB%B6/"/>
    <id>https://cjsmy1973.github.io/2019/08/11/Json文件/</id>
    <published>2019-08-11T15:45:34.000Z</published>
    <updated>2019-08-12T07:40:26.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Json文件"><a href="#Json文件" class="headerlink" title="Json文件"></a>Json文件</h1><p>json文件最为常用的配置文件(尤其是web项目)，有着数据格式比较简单, 易于读写, 格式都是压缩的,占用带宽小的特点。在C#中,操作json文件的常用方法是第三方类库<code>json.net</code>.</p><h2 id="Json文件作为配置文件使用"><a href="#Json文件作为配置文件使用" class="headerlink" title="Json文件作为配置文件使用"></a>Json文件作为配置文件使用</h2><p>那么下面让我们来学习如何使用<code>json.net</code>类库。</p><h3 id="导入Json配置文件转化为对应实体类"><a href="#导入Json配置文件转化为对应实体类" class="headerlink" title="导入Json配置文件转化为对应实体类"></a>导入Json配置文件转化为对应实体类</h3><p>通常我们需要从指定路径Path中读取配置文件转化为我们想要的实体类，假设我们现在的json文件是个json数组，如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;&quot;Key&quot;:&quot;test&quot;,&quot;Value&quot;:&quot;test&quot;&#125;,</span><br><span class="line">&#123;&quot;Key&quot;:&quot;test&quot;,&quot;Value&quot;:&quot;test&quot;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>我们自定的实体类Model.cs如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Model&#123;</span><br><span class="line">public string Key &#123; get; set; &#125;</span><br><span class="line">    public string Value &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们可以考虑从json文件读取并反序列化我们想要的实体类对象，其中用到了<code>json.net</code>的JsonSerializer类和JsonReader类，代码如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public LoadConfig&#123;</span><br><span class="line">    Ilist configs=new list&lt;Model&gt;();</span><br><span class="line">    using (var file = File.OpenText($&quot;&#123;YourFilePath&#125;&quot;))&#123;</span><br><span class="line">    JsonSerializer serializer = new JsonSerializer();//json.net序列化对象类</span><br><span class="line">    JsonReader reader = new JsonTextReader(file);//构建Json.net的读取流</span><br><span class="line">    configs = serializer.Deserialize&lt;List&lt;Model&gt;&gt;(reader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就把存储json数组的json文件转化了我们想要的集合对象,有人可能会问了，那我们如果想转化的是个普通的json对象，该怎么办呢？emmmm。。。如过反序列化为泛型对象都会了，想必一个普通对象肯定是难不到大家的对不对(ง •_•)ง</p><h3 id="将已有对象写入json配置文件"><a href="#将已有对象写入json配置文件" class="headerlink" title="将已有对象写入json配置文件"></a>将已有对象写入json配置文件</h3><p>既然我们可以利用Reader类读取json文件并利用Serializer类反序列化得到我们想要的对象，相反的，我们也可以利用Writer类将序列化的json字符串写入json配置文件，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public LoadConfig(string yourPath)&#123;</span><br><span class="line">    using (StreamWriter sw = new StreamWriter($@&quot;&#123;yourPath&#125;&quot;))</span><br><span class="line">    using (JsonWriter writer = new JsonTextWriter(sw))</span><br><span class="line">    &#123;</span><br><span class="line">        serializer.Serialize(writer, configs);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Web应用中json的使用"><a href="#Web应用中json的使用" class="headerlink" title="Web应用中json的使用"></a>Web应用中json的使用</h2><p>json不仅仅是作为配置文件使用，在互联网时代，更多的后台与网页前端通讯的文件格式，通常情况下，前端请求参数包装成一个json文件，后端返回的也是以一个包装过的json对象，但实际上，后端返回给前端的是个json字符串，那么在作为后端的我们应该怎么操作呢？</p><h3 id="JsonConvert对象序列化对象"><a href="#JsonConvert对象序列化对象" class="headerlink" title="JsonConvert对象序列化对象"></a>JsonConvert对象序列化对象</h3><p>JsonConvert序列化为对象比较简单，直接上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public string GetResult(Model model)&#123;</span><br><span class="line">    string json = JsonConvert.SerializeObject(model);</span><br><span class="line">    return json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JsonConvert对象反序列化对象"><a href="#JsonConvert对象反序列化对象" class="headerlink" title="JsonConvert对象反序列化对象"></a>JsonConvert对象反序列化对象</h3><p>但是涉及到反序列化时，就需要谨慎一些了，我们都知道当一个对象过大时，它可能以大对象堆的形式占用内存，而且GC回收器不会去压缩大对象堆，所以对于json文件是否超过85kb我们应该分情况处理</p><h4 id="文件大小小于85kb"><a href="#文件大小小于85kb" class="headerlink" title="文件大小小于85kb"></a>文件大小小于85kb</h4><p>直接使用JsonConvert反序列化对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Model GetResult(string json)&#123;</span><br><span class="line">    Model result = JsonConvert.DeserializeObject&lt;Model&gt;(json);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件大于85kb"><a href="#文件大于85kb" class="headerlink" title="文件大于85kb"></a>文件大于85kb</h4><p>当json数据大于85KB时，应该使用流式传输，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Model GetResult(Stream json)&#123;//这里我偷懒了(￣▽￣)&quot;</span><br><span class="line">    using (StreamReader sr = new StreamReader(json))</span><br><span class="line">    using (JsonReader reader = new JsonTextReader(sr))</span><br><span class="line">    &#123;</span><br><span class="line">        JsonSerializer serializer = new JsonSerializer();</span><br><span class="line">        Model p = serializer.Deserialize&lt;Model&gt;(reader);</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>写了篇简单的<code>json.net</code>的使用的博客，请各位大佬勿喷(<em>^_^</em>)，关于<code>json.net</code>其实还有很多高级的用法(比较多，懒得写(￣_￣|||))，之前vs新闻上有告知<code>.net core</code> 更新了新的了个微软自己封装的关于json解析序列化的类，有时间可以继续研究研究，希望学习更多有关<code>json.net</code>的知识可以访问<a href="https://www.newtonsoft.com/json" target="_blank" rel="noopener">官网</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Json文件&quot;&gt;&lt;a href=&quot;#Json文件&quot; class=&quot;headerlink&quot; title=&quot;Json文件&quot;&gt;&lt;/a&gt;Json文件&lt;/h1&gt;&lt;p&gt;json文件最为常用的配置文件(尤其是web项目)，有着数据格式比较简单, 易于读写, 格式都是压缩的,占用
      
    
    </summary>
    
      <category term="文件类" scheme="https://cjsmy1973.github.io/categories/%E6%96%87%E4%BB%B6%E7%B1%BB/"/>
    
    
      <category term="配置文件" scheme="https://cjsmy1973.github.io/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
</feed>
